#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <pthread.h>

#define WRITE 1
#define READ 0

#define MAX_CHILDREN 5
#define MAX_BUF 100

int isChild = 0;

typedef struct s_t_args{
    pid_t pidArr[MAX_CHILDREN];
    char lastInString[MAX_BUF];
    int childrenNr;
    int FDs[MAX_CHILDREN][2];
    int signal;
} thread_args;

thread_args t_args; 

void myHandler(int sig);
void* sendMsgs(void * args);
void receiveHandler(int childIndex, thread_args _args);

int main(){
    
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_handler = myHandler;
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);

    char buf[MAX_BUF];
    int childIndex = 0;
    t_args.childrenNr = 0;

    printf("[MAIN] main PID is %d\n", getpid());
    fflush(stdout);

    while(1){

        int r = 0;
        while(r <= 0){
            r = read(STDIN_FILENO, buf, MAX_BUF);
        }
        printf("\n");
        printf("________________________________________\n");
        if(r < 0){
            fprintf(stderr, "An error occurred while reading from stdin.\n");
            fflush(stderr);
            return 1;
        } else{
            buf[r-1] = 0;
        }
        int isNumber = atoi(buf);
        if(!isNumber){
            strcpy(t_args.lastInString, buf);
            printf("[MAIN] Msg '%s' saved\n", t_args.lastInString);
        } else{
            if( (t_args.childrenNr++) < MAX_CHILDREN ){
                if(pipe(t_args.FDs[t_args.childrenNr-1])){
                    fprintf(stderr, "An error occurred while creating a pipe\n");
                    fflush(stderr);
                    return 2;
                }
                t_args.pidArr[t_args.childrenNr-1] = fork();
                if(!t_args.pidArr[t_args.childrenNr-1]){
                    isChild = 1;
                    childIndex = t_args.childrenNr-1;
                    printf("[CHD] I'm new child with PID %d, and I'm waiting for msg from father\n", getpid());
                }
            } else{
                fprintf(stderr, "Too much children\n");
            }
        }

        if(isChild){
            receiveHandler(childIndex, t_args);
        }

    }
    return 0;
}

// Handler for SIGUSR1 & SIGUSR2
void myHandler(int sig){

    if(sig == SIGINT || sig == SIGTERM){
        while(wait(NULL) > 0);
        exit(0);
    } else{
        pthread_t t;
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        t_args.signal = sig;

        if(pthread_create(&t, &attr, sendMsgs, (void *)&t_args)){
            fprintf(stderr, "\nAn error occurred while opening a thread\n");
        }
        pthread_join(t, NULL);
        t_args.childrenNr = 0;
    }
    return ;
}

// Function for sending messages to children
void* sendMsgs(void * args){
    thread_args _args = *(thread_args *)args;
    char msgs[_args.childrenNr][MAX_BUF];
    char tmpArg[10];

    char logBuf[MAX_BUF];
    logBuf[0] = 0;
    int logFD = open("/tmp/log.txt", O_WRONLY | O_CREAT | O_APPEND);
    int ret = 0;

    strcpy(logBuf, "[THREAD] I'm new thread generated by signal\0");
    ret = sprintf(tmpArg, "%d", _args.signal);
    tmpArg[ret] = 0;
    strcat(logBuf, tmpArg);

    write(logFD, logBuf, strlen(logBuf));
    write(logFD, "[THREAD] Sending messages to children\n", strlen("[THREAD] Sending messages to children\n"));

    for(int i = 0; i < _args.childrenNr; i++){
        
        strcpy(msgs[i], "To Child \0");
        //msgs[i][strlen("To Child ")] = 0;
        ret = sprintf(tmpArg, "%d", i);
        //tmpArg[ret] = 0;
        strcat(msgs[i], tmpArg);
        
        strcat(msgs[i], " PID ");
        ret = sprintf(tmpArg, "%d", (int)_args.pidArr[i]);
        //tmpArg[ret] = 0;
        strcat(msgs[i], tmpArg);
        //msgs[i][ret] = ':';
        //msgs[i][ret+1] = ' ';
        //msgs[i][ret+2] = '\0';

        strcat(msgs[i], _args.lastInString);
        close(_args.FDs[i][READ]);
        write(_args.FDs[i][WRITE], msgs[i], strlen(msgs[i])+1);

        printf("[THREAD] msg = '%s'\n", msgs[i]);

    }

    write(logFD, "[THREAD] Children reset\n", strlen("[THREAD] Children reset\n"));
    write(logFD, "[THREAD] Terminating thread\n", strlen("[THREAD] Terminating thread\n"));
    write(logFD, "\n",1);

    pthread_exit(NULL);
}

void receiveHandler(int childIndex, thread_args _args){
    char buf[MAX_BUF];
    close(_args.FDs[childIndex][WRITE]);
    int r = 0;
    while(r == 0){
        r = read(_args.FDs[childIndex][READ], buf, MAX_BUF);
    }
    if(r < 0){
        fprintf(stderr, "An error occurred while reading the pipe of child nr [%d].\n", childIndex);
        exit(0);
    }

    buf[r] = 0;
    sleep(1);
    printf("[CHD] I received the following message: '[%s]'\n", buf);
    fflush(stdout);
    sleep(1);

    exit(0);
}